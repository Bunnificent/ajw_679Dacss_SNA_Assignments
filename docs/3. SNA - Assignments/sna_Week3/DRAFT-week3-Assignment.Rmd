---
title: "DRAFT: Week 3: Degree and Centrality"
description: " "
author:
  - name: "Audra Jamai White" 
    url: 
    affiliation: "Umass Amherst - DACSS 679: Social Network Analysis"
    affiliation_url: 
date: "`r Sys.Date()`"
output: distill::distill_article
---

```{r setup, Libraries, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

# Document Creation
library(knitr)
library(markdown)
library(yaml)
library(distill)
library(blogdown)

# Basic Analysis
library(ggplot2)
library(tidyverse)
library(clipr)
library(dbplyr)
library(data.table)
library(stringr)
library(stringi)
library(tibble)
library(tidyr)

# SNA - Social Network Analysis

library(tergm)
library(ergm)
library(network)
library(networkDynamic)
library(networkDynamicData)

library(statnet)
library(igraph)
library(igraphdata)
library(tsna)
library(sna)

```
  
## Briefly describe the dataset:
1.   identify initial network format; 
2.   describe and identify the nodes 
     including: 
        *  how many nodes are in the dataset; 
3.   what constitutes a tie or edge
     including:
        *  how many ties, 
        *   whether ties are directed/undirected,
        *   whether ties are weighted/binary, 
        *   and how to interpret the value of the tie if any.
        *   Whether or not there are edge attributes 
            that might be used to:
            *   subset data, or 
            *   stack multiple networks. 

# Week 2: Scripts
## Smuggler's Index: Network Attributes  
  - Edgelist
  - unweghted
  - undirected
 
Network attributes:

*statnet*
  vertices = 274
  directed = TRUE
  hyper = FALSE
  loops = FALSE
  multiple = FALSE
  bipartite = FALSE
 total edges = 671 
   missing edges = 0 
   non-missing edges = 0 
 density = 0 

Edge attributes:
[1]ingTyp:
   character valued attribute

Attribute summary:
  the 10 most common values are:
  JUICE     RUM   SYRUP LIQUEUR BITTERS    SODA   SPICE     GIN  BRANDY   FRUIT 
    135     125     115      84      54      28      19      12       9       7 



###   IGRAPH:   Network Description
*igraph*
- Network Size
  - Number Vertex: 274
    - attr: name (v/c)
  - Number Edges: 672
    - attr: ingTyp (e/c)
- Bipartite: FALSE
- Directed: FALSE
- Weighted: FALSE

Names
- Vertex Names: view
- Edge Attribute Names: [1] "ingTyp"
```{r igraph: Network Description, echo=TRUE} 

summary(igEL)
#     Count Vertices
    vcount(igEL)

#     Count Edges
    ecount(igEL)

# Is this a Bipartite or single mode network?
    is_bipartite(igEL)

#  Are edges directed or undirected?
    is_directed(igEL)

#Are edges weighted or unweighted?
    is_weighted(igEL)        
    
```

```{r igraph: Vertex & Attribute info, echo=TRUE}
library(igraph)

#     access vertex attribute 
  head(V(igEL)$name,20)
#     Generate a list the names of vertex attributes
  print(igraph::vertex_attr_names(igEL))

#     access edge attribute
  head(E(igEL)$ingTyp, 20)

#   Generate a list the names of edge attributes  
  igraph::edge_attr_names(igEL)

#   summarize numeric network attribute
  summary(E(igEL)$weight)  

```

 
###   STATNET:   Network Description 
 *statnet*
  vertices = 274
  directed = TRUE
  hyper = FALSE
  loops = FALSE
  multiple = FALSE
  bipartite = FALSE
 total edges = 671 
   missing edges = 0 
   non-missing edges = 0 
 density = 0 

Edge attributes:

 ingTyp:
   character valued attribute
   attribute summary:
   the 10 most common values are:
  JUICE     RUM   SYRUP LIQUEUR BITTERS    SODA   SPICE     GIN  BRANDY   FRUIT 
    135     125     115      84      54      28      19      12       9       7 
```{r statnet: Network Summary & Attribute info, echo=TRUE}

summary(snEL)
print(snEL)
#     access vertex attributes
 head(snEL %v% "vertex.names")

#      list the names of vertex attributes
  network::list.vertex.attributes(snEL)

#     access edge attribute
  head(snEL%e% "ingTyp")

#  Generate a list the names of edge attributes
  network::list.edge.attributes(snEL)
 
#   summarize numeric network attribute
  summary(snEL  %v% "name")
  
```


```{r STATNET: Component Size Distribution}
library(statnet)
library(sna)

component.dist(
  snEL, 
  connected= c("unilateral")) # c("strong","weak","unilateral","recursive"))

component.largest(
  snEL, 
  connected = c("unilateral"), #=c("strong","weak","unilateral" "recursive")
  result = c("graph"), #c("membership", "graph") 
  return.as.edgelist = FALSE)

```

##### Details: Component Size Distribution 
Components are maximal sets of mutually connected vertices; depending on the definition of “connected” one employs, one can arrive at several types of components. Those supported here are as follows (in increasing order of restrictiveness):

weak: v_1 is connected to v_2 iff there exists a semi-path from v_1 to v_2 (i.e., a path in the weakly symmetrized graph)

unilateral: v_1 is connected to v_2 iff there exists a directed path from v_1 to v_2 or a directed path from v_2 to v_1

strong: v_1 is connected to v_2 iff there exists a directed path from v_1 to v_2 and a directed path from v_2 to v_1

recursive: v_1 is connected to v_2 iff there exists a vertex sequence v_a,...,v_z such that v_1,v_a,...,v_z,v_2 and v_2,v_z,...,v_a,v_1 are directed paths



##  Path Length and Geodesic Distance

- Nodes: 
  - (v/c) Drink Names
  - (v/c) Drink Ingredients
- Links: 
  - (e/c)  Ingredient Type

###  Statnet:   Path Length and Geodesic Distance
 
```{r STATNET:Path: Reachability}
library(statnet)
library(sna)



```


```{r STATNET:Path: Geodesic number & lengths}
library(statnet)
library(sna)

summary(geodist(snEL, 
        inf.replace=Inf, 
        count.paths=TRUE, # include geodesics 
        predecessors=FALSE,# include predecessor list
        ignore.eval=FALSE, # ignore edge values
        na.omit=FALSE) # remove NA-values edges
        )
```

```{r STATNET:Path: k Path Census}
library(statnet)
library(sna)

summary(kpath.census(snEL, 
             maxlen = 5, 
             mode = "graph",
             tabulate.by.vertex = TRUE, 
             path.comembership = c("none"), # c("none", "sum","bylength"), 
             dyadic.tabulation = c("none") # c("none", "sum", "bylength"))
))
              ##**"sum"* returns a vertex by vertex matrix of source/destination path counts
             ##**"bylength"* disaggregates these counts by path length. 
             ##**"none"* disables this computation.


```
- Aggregate counts of paths/cycles by length (i.e., k).

- Counts of paths/cycles to which each vertex belongs (when tabulate.byvertex==TRUE).

- Counts of path/cycle co-memberships, potentially disaggregated by length (when the appropriate co-membership argument is set to bylength).

- For path.census, counts of the total number of paths from each vertex to each other vertex, possibly disaggregated by length (if dyadic.tabulation=="bylength").


###  IGRAPH:   Path Length and Geodesic Distance

```{r iGraph:Nodes: Path: Length, echo=TRUE}
library(igraph)

# Head
head(V(igEL)$name,10)
head(E(igEL)$ingTyp, 10)

#Tail
tail(V(igEL)$name,10)
tail(E(igEL)$ingTyp, 10)
    
```

  # 20 Vertex Names 
      
      Head, 10 + Tail, 10
 [1] "AKU AKU"                    
 [2] "(1-INCH-SQUARE) CHUNKS PINEAPPLE"    
 [3] "MINT LEAVES"                
 [4] "LIME JUICE"    
 [5] "DEMERARA SYRUP"             
 [6] "PEACH LIQUEUR (SUCH AS MATHILDE, COMBIER, OR GIFFARD)"
 [7] "BLENDED LIGHTLY AGED RUM"   
 [8] "PUPULE" 
 [9] "ORANGE JUICE"               
 [10] "CINNAMON SYRUP"
 [1] "SINGAPORE SLING"                     
      "BENEDICTINE"
      "HONDO HATTIE'S JUNGLE PUNCH!"    
  [4] "KAHIKO PUNCH"
      "PASSION FRUIT HONEY"                 
      "TRIUMVIRATE PUNCH"   
  [7] "EUREKA PUNCH"                         
      "YULETIDAL WAVE"
      "RUMBUSTION PUNCH"                
 [10] "PUKA PUNCH"   


  The shortest path to describe the overall network structure 
```{r iGraph:Network: Path: Shortest, echo=TRUE}

#     find average shortest path for network
    average.path.length(igEL,directed=F)    
  
```   
  

```{r iGraph:Nodes: Path: Length, echo=TRUE}
library(igraph)

#     Calculate distance between two nodes using unweighted edges
 
    distances(igEL,"AKU AKU" ,  "SINGAPORE SLING",weights=NA)
    distances(igEL,"AKU AKU" ,  "HONDO HATTIE'S JUNGLE PUNCH!",weights=NA)
    distances(igEL,"AKU AKU" ,"KAHIKO PUNCH" ,weights=NA)
    distances(igEL,"AKU AKU" , "PASSION FRUIT HONEY"   ,weights=NA)
    distances(igEL,"AKU AKU" , "TRIUMVIRATE PUNCH"   ,weights=NA)
    distances(igEL,"AKU AKU" ,"EUREKA PUNCH" ,weights=NA)
    distances(igEL,"AKU AKU" , "YULETIDAL WAVE" ,weights=NA)
    distances(igEL,"AKU AKU" ,"RUMBUSTION PUNCH"   ,weights=NA)
    distances(igEL,"AKU AKU" ,"PUKA PUNCH",weights=NA)

```

Find *all* of the shortest paths between two specific nodes in this network.

```{r iGraph:Nodes: Path: Shortest, echo=TRUE}
    
#     isolating the distances between specific node

## Note: manually tell igraph to ignore edge weights.

all_shortest_paths(igEL,
                     "AKU AKU" ,
                     "SINGAPORE SLING",
                     weights=NA)$res
 
all_shortest_paths(igEL,
                   "AKU AKU",
                   "HONDO HATTIE'S JUNGLE PUNCH!",
                   weights=NA)$res
  
all_shortest_paths(igEL,
                   "AKU AKU",
                   "KAHIKO PUNCH",
                   weights=NA)$res

all_shortest_paths(igEL,
                     "AKU AKU", 
                     "PASSION FRUIT HONEY",
                     weights=NA)$res
  
all_shortest_paths(igEL,
                   "AKU AKU",
                   "TRIUMVIRATE PUNCH",
                   weights=NA)$res
  
  all_shortest_paths(igEL,"AKU AKU",
                     "EUREKA PUNCH",
                     weights=NA)$res
  
  all_shortest_paths(igEL,"AKU AKU", 
                     "YULETIDAL WAVE" ,
                     weights=NA)$res
  
  all_shortest_paths(igEL,
                     "AKU AKU" ,
                     "RUMBUSTION PUNCH",
                     weights=NA)$res
  
  all_shortest_paths(igEL,
                     "AKU AKU" ,
                     "PUKA PUNCH",
                     weights=NA)$res
```   
    


6.  *triads or transitivity,*

## Dyad Census

Classifies all dyads in the network as:
- Mutual - Reciprocal (mutual) 
- Asymmetric -  (non-mutual), 
- Null - Absent

```{r statnet: Dyad Census , echo=TRUE}
library(statnet)
    sna::dyad.census(snEL)

```
```{r iGraph: Dyad Census, echo=TRUE}
library(igraph)
  
dyad.census(igEL)

```

## Triad Census

Classifies all triads in the network. 


```{r statnet: Triad Census, echo=TRUE}
library(sna)
#     Classify all Triad in the network: 

#Directed Network
#**triad.census(snEL, mode="digraph")*

#     Classify all Triad in the network: Undirected Network
   sna::triad.census(
     snEL,
     mode="graph")
     

#     total number of all four triad types returned by triad census
   sum(
     sna::triad.census(
       snEL,
       mode="graph")
     )
  
#Davis and Leinhardt classification of the triad classification scheme 
   # describes each triad by a string of four elements: 
   # the number of mutual (complete) dyads within the triad; 
   # the number of asymmetric dyads within the triad; 
   # the number of null (empty) dyads within the triad; 
   #and a configuration code for the triads which are not uniquely distinguished by the first three distinctions.
   
   sna::triad.classify(
     snEL,
     tri=c(1,2,3),
     mode==c("digraph")
   )
  #Classify the triads (1,2,3) and (2,3,4)

   triad.classify(snEL,tri=c(1:14))
   gplot(snEL,c[1:14])
   
```

```{r iGraph: Triad Census, echo=TRUE}
library(igraph)
#Classify all Triad in the network
     igraph::triad_census(igEL)

```


## Transitivity or Global Clustering

```{r iGraph: weighted/ network transitivity, echo=TRUE}

#     network transitivity:
    transitivity(igEL)

#     weighted network transitivity:
#   igraph::transivity(igEL)

```

```{r statnet: weighted/ directed network transitivity, echo=TRUE}

#     Directed Networks transitivity:
  gtrans(snEL)

#   methods for weighted networks, rank and correlation, along with the relevant references.
#  sna::gtrans()
  
```


## Local Transivity or Clustering
`Local transitivity` (local clustering coefficient), is a technical description of the density of an ego network.

```{r iGraph:Local transitivity, echo=TRUE}

#     Retrive a list of the vertices we are interested
    V(igEL)[c("" ,
                "", 
                "Medici",
                "")]

#     check ego network transitivity
transitivity(igEL,
             type="local", 
             vids=V(igEL)
             [c("",
                "", 
                "Medici",
                "")]) 
#     get global clustering cofficient
  transitivity(igEL, type="global")

#     get average local clustering coefficient
  transitivity(igEL, type="average")

```


7.  *connectedness and.or component structure, etc.*




 
> Distill is a publication format for scientific and technical writing, native to the web.
>
> Learn more about using Distill for R Markdown at <https://rstudio.github.io/distill>.
##

