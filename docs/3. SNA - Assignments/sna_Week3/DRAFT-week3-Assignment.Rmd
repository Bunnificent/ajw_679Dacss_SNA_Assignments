---
title: "DRAFT: Week 3: Degree and Centrality"
description: " "
author:
  - name: "Audra Jamai White" 
    url: 
    affiliation: "Umass Amherst - DACSS 679: Social Network Analysis"
    affiliation_url: 
date: "`r Sys.Date()`"
output: distill::distill_article
---

```{r setup, Libraries, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

# Document Creation
library(knitr)
library(markdown)
library(yaml)
library(distill)
library(blogdown)

# Basic Analysis
library(ggplot2)
library(tidyverse)
library(clipr)
library(dbplyr)
library(data.table)
library(stringr)
library(stringi)
library(tibble)
library(tidyr)

# SNA - Social Network Analysis

library(tergm)
library(ergm)
library(network)
library(networkDynamic)
library(networkDynamicData)

library(statnet)
library(igraph)
library(igraphdata)
library(tsna)
library(sna)

```

## Briefly describe the dataset:

1.  identify initial network format;

2.  describe and identify the nodes including:

    -   how many nodes are in the dataset;

3.  what constitutes a tie or edge including:

    -   how many ties,

    -   whether ties are directed/undirected,

    -   whether ties are weighted/binary,

    -   and how to interpret the value of the tie
        if any.

    -   Whether or not there are edge attributes
        that might be used to:

        -   subset data, or
        -   stack multiple networks.

# Week 2: Scripts

## Smuggler's Index: Network Attributes

```{r Network Size & Info}

  
  print(snEL)
  summary(snEL)
  network::has.loops(snEL)
  network::is.directed(snEL)
  network::is.bipartite(snEL)
  network::is.hyper(snEL) # hypergraphic edges allowed
  network::is.multiplex(snEL) # multiplex edges allowed
  
  print_all(igEL)
  summary(igEL)
  igraph::is_directed(igEL)
  summary(
  igraph::is.loop(igEL))





```

plot.network(snEL) igraph::plot.igraph(igEL)

### IGRAPH: Network Description

*igraph* - Network Size - Number Vertex: 274 -
attr: name (v/c) - Number Edges: 672 - attr:
ingTyp (e/c) - Bipartite: FALSE - Directed: FALSE
- Weighted: FALSE

Names - Vertex Names: view - Edge Attribute Names:
[1] "ingTyp"

```{r igraph: Network & Attribute Descripions, echo=TRUE}

## Network Size
#     Count Vertices
    vcount(igEL)
#     Count Edges
    ecount(igEL)

## Network Attributes
    
# Is this a Bipartite or single mode network?
    is_bipartite(igEL)

#  Are edges directed or undirected?
    is_directed(igEL)

#Are edges weighted or unweighted?
    is_weighted(igEL)        
    
# vertex attribute names
  igraph::vertex_attr_names(igEL)

#   edge attributes  names
  igraph::edge_attr_names(igEL)

#   summarize numeric network attribute
#**summary(E(igEL)$weight)*

```

```{r igraph: Vetex & Edge Names, echo=TRUE}
library(igraph)

#     access vertex attribute 
  head(
    V(igEL)$name,20)

#     access edge attribute
  head(E(igEL)$ingTyp, 20)

```

### STATNET: Network Description

```{r statnet: Network Summary & Attribute info, echo=TRUE}

print(summary(snEL))

  network::list.network.attributes(snEL)
#      list the names of vertex attributes
  network::list.vertex.attributes(snEL)
#  Generate a list the names of edge attributes
  network::list.edge.attributes(snEL)
 
#   summarize numeric network attribute
  summary(snEL%v%"name")
  summary(snEL%v%"ingNam")
  summary(snEL%v%"dnkNam")
  summary(snEL%e%"ingTyp")
  
  
#     access vertex & edge attribute names
 head(snEL %v% "vertex.names")
#     access edge attribute
  head(snEL%e%"ingTyp")
  
```

## Dyad Census

Classifies all dyads in the network as: - Mutual -
Reciprocal (mutual) - Asymmetric - (non-mutual), -
Null - Absent

```{r iGraph: Dyad Census, echo=TRUE}
library(igraph)

dyad.census(igEL)
print("Undirected graph, $asym is 0")

```

```{r iGraph: Dyad: Graph Density / Edge Density, echo=TRUE}
library(igraph)

  graph.density(igEL)

summary(
  graph.density(igEL)
)
 
    ## Density captures, at the macro-level, the proportion of dyads that are present over the possible total number of dyads in the network
  
  edge_density(igEL)
  
summary(
   edge_density(igEL)
)

      # Generating a random graph for comparison
# erdos.renyi.game
      ## In an erdos.renyi.graph, each edge has the same probability of being created. We determine the probability and it returns a random graph with a density that equals (in expectation) this probability.

igEL_Nod <- vcount(igEL)

igEL_Den <- graph.density(igEL)

 igEL_randoGraph <- erdos.renyi.game(
    n = igEL_Nod, 
    p.or.m = igEL_Den, 
    directed = T) 
      # where n is the number of nodes, 
      # p.or.m is the probability of drawing an edge, 
      #directed is whether the network is directed or not
 class(igEL_randoGraph)
 summary(igEL_randoGraph)
 
 
 print_all(igEL_randoGraph)

```




```{r iGraph: GRAPH: Dyad Census, echo=TRUE}

plot(
  igEL_randoGraph, 
  vertex.size = 5,
  vertex.label = NA, 
  edge.curved = .1, 
  vertex.color= "tomato", 
  edge.arrow.size = .1, edge.width = .5,
  edge.color = "grey60")

graph.density(igEL)
    ## Density captures, at the macro-level, the proportion of dyads that are present over the possible total number of dyads in the network

      # Generating a random graph for comparison
# ?erdos.renyi.game
      ## In an erdos.renyi.graph, each edge has the same probability of being created. We determine the probability and it returns a random graph with a density that equals (in expectation) this probability.

igELNod <- vcount(igEL)

igELDen <- graph.density(igEL)

smugEL_DigRandoG <- 
  erdos.renyi.game(
    n = igELNod, 
    p.or.m = igELDen, 
    directed = T) 
      # where n is the number of nodes, 
      # p.or.m is the probability of drawing an edge, 
      #directed is whether the network is directed or not

#**plot(smugEL_DigRandoG, ...** in .R notebook  
     # vertex.size = 5, 
     # vertex.label = 1, 
     # edge.curved = .1, 
     # vertex.color = "tomato", 
     # edge.arrow.size = .1, 
     # edge.width = .5, 
     # edge.color = "grey60")

```



```{r statnet: Dyad Count / Dyad Census , echo=TRUE}
library(statnet)
library(sna)

 network.dyadcount(snEL)
 sna::dyad.census(snEL)
 
     print("statnet thinks it's a directed network, so there are no mutual ties because it's an undirected network and the 'names' and 'ingredients' in a recipie do not have a reciprocal relationship. If anything the 'flow of info' moves from 'Drink Name' to 'Drink Ingredient' to 'Ingredient type'. The Drink name determines the recipie ingredients, but we're unable to identify a drink by calling on individual ingredients in a recipie")  
  
```

gplot(sna::dyad.census(snEL))

```{r statnet: GRecip / Mutuality, echo=TRUE}
library(statnet)
library(sna)
  
#  the number of complete dyads (i.e., i<->j)
mutuality(snEL)


  grecip(snEL) 
  
    #proportion of symmetric dyads
  grecip(snEL, 
         measure = "dyadic") 
  
      # returns the ratio of mutuals to non-null dyads.
  grecip(snEL, 
         measure = "dyadic.nonnull") 
  
      # the proportion of edges which are reciprocated
  grecip(snEL, 
         measure = "edgewise") 
  
      # returns the log of the ratio of the edgewise reciprocity to the density
  grecip(snEL, 
         measure = "edgewise.lrr") 
      
  # The correlation measure may be interpreted as the net tendency for edges of similar relative value (with respect to the mean edge value) to occur within the same dyads. 

    grecip(snEL, 
         measure = "correlation") 
```

## Triad Census

Classifies all triads in the network.

```{r iGraph: Triad Census, echo=TRUE}
library(igraph)
#Classify all Triad in the network

sum(
  triad_census(igEL)
)

igEL_triList <- 
  triad_census(igEL)



```

plot(igEL_triList)

```{r statnet: Triad Census / Triad Classify, echo=TRUE}
library(sna)

#     total number of all four triad types returned by triad census

#     Classify all Triad in the network

  sna::triad.census(
    snEL,
    mode="graph")

view(
 sna::triad.census(
     snEL,
     mode="digraph")
))
  
#Davis and Leinhardt classification of the triad classification scheme 
   # describes each triad by a string of four elements: 
   # the number of mutual (complete) dyads within the triad; 
   # the number of asymmetric dyads within the triad; 
   # the number of null (empty) dyads within the triad; 
   #and a configuration code for the triads which are not uniquely distinguished by the first three distinctions.
   
sna::triad.classify(
     snEL,
     tri=c(1,2,3),
     mode==c("graph"))

sna::triad.classify(
     snEL,
     tri=c(1:16),
     mode==c("digraph"))

```

plot(view( sna::triad.census( snEL,
mode="digraph") ))

plot(view( sna::triad.census(snEL,mode="graph")))

## Transitivity or Global Clustering

Perportion of connected triads to complete triads

```{r iGraph: Transitivity Network, echo=TRUE}
library(igraph)

# Calculate the maximal (weakly or strongly) connected components of a graph
igraph::cluster.distribution()

#     network transitivity:
 transitivity(igEL)

 summary(  
  transitivity(
   igEL,
   type = c("undirected"),
   vids = NULL, #  all vertices are considered.
   weights = NULL,
   isolates = c("zero"))
)

summary( 
 transitivity(igEL,
             type = c("globalundirected"),
             vids = NULL, #  all vertices are considered.
             weights = NULL,
             isolates = c("zero"))
)

summary(
  transitivity(igEL,
             type = c("localundirected"),
             vids = NULL, #  all vertices are considered.
             weights = NULL,
              isolates = c("zero"))
)
#   c("undirected", "global", "globalundirected", "localundirected", "local","average", "localaverage","localaverageundirected", "barrat", "weighted")

```

```{r statnet: PLOT: Transitivity:, echo=FALSE}
library(statnet)
library(sna)

#   Networks transitivity:
print("Networks transitivity:")  
print("Note: where missing values prevent the assessment of whether a triple is transitive, that triple is omitted.")

print("use.adjacency=FALSE -> 0: completely intransitive ")        
  gtrans(snEL,
         mode="digraph", #"digraph" for triads 
         use.adjacency=FALSE)

print("use.adjacency=TRUE -> 1: completely transitive")
  gtrans(snEL, 
         mode="graph", # No triads
         use.adjacency=TRUE)

# Unaffected by mode=digrag/graph, diag(nal)=F/T
      
#   measure = 
  ## c("weak", "strong", "weakcensus", "strongcensus", "rank", "correlation"), 

print("Weak Ties: fraction of potentially intransitive triads returned")
  ## Weak Ties
  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("weak"),
    use.adjacency=FALSE)
    
  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("weak"),
     use.adjacency=TRUE)
   
print("weak census: total number of transitive triads is computed")  
  ## "weakcensus"
  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("weakcensus"),
    use.adjacency=TRUE)

  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("weakcensus"),
    use.adjacency=FALSE)

  
print("strong ties")  
  ## Strong Ties
  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("strong"),
    use.adjacency=TRUE)

  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("strong"),
    use.adjacency=FALSE)
  
print("strongcensus: total number of all (in/transitive) triad sets considered")
  ## "strongcensus"
gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("strongcensus"),
    use.adjacency=FALSE)

  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("strongcensus"),
    use.adjacency=TRUE)
  
print("rank")  
  ##  "rank"
gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c( "rank"),
    use.adjacency=FALSE)
  
  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c( "rank"),
    use.adjacency=TRUE)
  
  
  ## "correlation"
print("correlation: the matrix correlation of the valued adjacency matrix A with its second power (i.e., A^2), omitting diagonal entries where inapplicable.")
  
  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("correlation"),
    use.adjacency=TRUE)

```

## Ego Network Transivity or Local Clustering

`Local transitivity` (local clustering
coefficient), is a technical description of the
density of an ego network.

```{r iGraph: Local / Ego Network Transitivity, echo=TRUE}
#     get global clustering cofficient
  transitivity(igEL,
               type="global")

#     get average local clustering coefficient
  transitivity(igEL,
               type="average")


#     check ego network transitivity
transitivity(igEL,
             type="undirected",
             vids=V(igEL)[c(
               "AKU AKU", 
               "SINGAPORE SLING",
               "HONDO HATTIE'S JUNGLE PUNCH!")])

```

```{r statnet: Local / Ego Network Transitivity}
library(statnet)
library(sna)
print("Ego Network Transitivity")

print("use.adjacency=TRUE -> 1: completely transitive")
gtrans(
    snEL,
    g=snEL%v%"AKU AKU",
    use.adjacency=T)

gtrans(
    snEL,
    g=snEL%v%"LIME JUICE",
    use.adjacency=T)

print("use.adjacency=FALSE -> 0: completely intransitive ")        
gtrans(
    snEL,
    g=snEL%v%"AKU AKU",
    use.adjacency=FALSE)

gtrans(
    snEL,
    g=snEL%v%"LIME JUICE",
    use.adjacency=FALSE)

#   measure = 
  ## c("weak", "strong", "weakcensus", "strongcensus", "rank", "correlation"), 


print("strong ties")  
  ## Strong Ties
  gtrans(
    snEL,
      g=snEL%v%"AKU AKU",
    mode="digraph", 
    measure = c("strong"),
    use.adjacency=FALSE)

  gtrans(
    snEL,
    g=snEL[c(
      "AKU AKU,KAHIKO PUNCH", "TRIUMVIRATE PUNCH", "EUREKA PUNCH",
      "YULETIDAL WAVE","RUMBUSTION PUNCH", "PUKA PUNCH")],
    mode="graph", 
    measure = c("strong"),
    use.adjacency=FALSE)
  
  gtrans(
    snEL,
    g=snEL%v%"LIME JUICE",
    mode="graph", 
    measure = c("strong"),
    use.adjacency=F)
  
 gtrans(
    snEL,
     g=snEL[c(
       "LIME JUICE","2:1 SIMPLE SYRUP","ALLSPICE BERRIES",
       "APPLE BRANDY"  ,"ABSINTHE BLANC","AQUAVIT","AMARO AVERNA")],
    mode="graph", 
    measure = c("strong"),
    use.adjacency=F)
 
  
print("strongcensus: total number of all (in/transitive) triad sets considered")
  
print("strongcensus")
    ## "strongcensus"
  gtrans(
    snEL,
      g=snEL%v%"AKU AKU",
    mode="graph", 
    measure = c("strongcensus"))

gtrans(
    snEL,
    g=snEL[c(
      "AKU AKU,KAHIKO PUNCH", "TRIUMVIRATE PUNCH", "EUREKA PUNCH",
      "YULETIDAL WAVE","RUMBUSTION PUNCH", "PUKA PUNCH")],
    mode="graph", 
    measure = c("strongcensus"))

gtrans(
    snEL,
   g=snEL%v%"LIME JUICE",
    mode="graph", 
    measure = c("strongcensus"))

  gtrans(
    snEL,
     g=snEL[c("LIME JUICE","2:1 SIMPLE SYRUP","ALLSPICE BERRIES","APPLE BRANDY"  ,"ABSINTHE BLANC","AQUAVIT","AMARO AVERNA")],
    mode="graph", 
    measure = c("strongcensus"))

```

## Path Length and Geodesic Distance

-   Nodes:

    -   (v/c) Drink Names
    -   (v/c) Drink Ingredients

-   Links:

    -   (e/c) Ingredient Type

### Statnet: Path Length and Geodesic Distance: Networks

```{r STATNET: Plot: Geodesic: Numbers and Lengths }
library(statnet)
library(sna)

#uses a BFS to find the number and lengths of geodesics between all nodes 

View(
geodist(snEL))

 gd_snEL <- geodist(
    snEL, 
    inf.replace=.25, #geodesics do not exist, substitute value
    count.paths=TRUE, 
    predecessors=F, # return predecessor list
    ignore.eval=T, # ignore edge values
    na.omit=T) # remove NA values

  #Examine the number of geodesics
snEL_gdCounts <- gd_snEL$counts
  sum(snEL_gdCounts)
  log_mean_exp(snEL_gdCounts)
  log_sum_exp(snEL_gdCounts)


#Examine the geodesic distances
 snEL_gdist  <- gd_snEL$gdist

  sum(snEL_gdist)
  log_mean_exp(snEL_gdist)
  log_sum_exp(snEL_gdist)

```

gplot(gd_snEL) in gplot(snEL_gdist)

```{r STATNET:Path: Reachability}
library(statnet)
library(sna)

summary(
  reachability(
    snEL,
    geodist.precomp= gd_snEL,
    return.as.edgelist=F,
    na.omit=F)
)
```

```{r STATNET:PLOT: Reachability}
library(statnet)
library(sna)

gplot(
  reachability(
    snEL,
    geodist.precomp= gd_snEL,
    return.as.edgelist=F,
    na.omit=F)
)
```

    K-Path Census

-   Aggregate counts of paths/cycles by length
    (i.e., k).

-   Counts of paths/cycles to which each vertex
    belongs (when tabulate.byvertex==TRUE).

-   Counts of path/cycle co-memberships,
    potentially disaggregated by length (when the
    appropriate co-membership argument is set to
    bylength).

-   For path.census, counts of the total number of
    paths from each vertex to each other vertex,
    possibly disaggregated by length (if
    dyadic.tabulation=="bylength").

```{r STATNET:Path: k Path Census}
library(statnet)
library(sna)

summary(kpath.census(snEL, 
             maxlen = 5, 
             mode = "graph",
             tabulate.by.vertex = T, 
             path.comembership = c("sum"), # c("none", "sum","bylength"),
             dyadic.tabulation = c("sum") # c("none", "sum", "bylength"))
))
              ##**"sum"* returns a vertex by vertex matrix of source/destination path counts
             ##**"bylength"* disaggregates these counts by path length. 
             ##**"none"* disables this computation.
```

```{r STATNET: PLOT: k Path Census}
library(statnet)
library(sna)

gplot(kpath.census(snEL, 
             maxlen = 10, 
             mode = "graph",
             tabulate.by.vertex = T, 
             path.comembership = c("bylength"), # c("none", "sum","bylength"),
             dyadic.tabulation = c("sum") # c("none", "sum", "bylength"))
))
              ##**"sum"* returns a vertex by vertex matrix of source/destination path counts
             ##**"bylength"* disaggregates these counts by path length. 
             ##**"none"* disables this computation.



```

### IGRAPH: Path Length and Geodesic Distance: Networks & Nodes

The shortest path to describe the overall network
structure

```{r iGraph: Path: Network & Nodes, echo=TRUE}
library(igraph)

#     find average shortest path for network
    average.path.length(igEL,
                        directed=F,
                       ig_histPath)

    igraph::path.length.hist(igEL)$no


#  shortest_paths calculates one shortest path (the path itself, and not just its length) from or to the given vertex.    

  shortest_paths(
  igEL,
  from=1,
  to = V(igEL),
  mode = c("all"),
  weights = NULL,
  output = c("epath"), #c("vpath", "epath", "both")
  predecessors = FALSE,
  inbound.edges = FALSE)$no

    all_shortest_paths(
      igEL,
      from = 1, # Vertex ID: AkuAku
      to = V(igEL),
      mode = c("all"),
      weights = NULL)$no
  
##**From=(vertex id)*	
    ##Numeric constant, the vertex from or to the shortest paths 

##**mode=c("out", "all", "in")*

##**output= *	
    ## defines how to report the shortest paths. 
  #**“vpath”* the vertices along the paths are reported, this form was used prior to igraph version 0.6. 
  #**“epath”* edges along the paths are reported. 
  #*“both”* both forms are returned, in a named list with components “vpath” and “epath”.
    
```

```{r iGraph: PLOT: PATH: Network & Nodes, echo=TRUE}
library(igraph)

 ig_histPath <-
view(
    igraph::path.length.hist(igEL)
)
#  shortest_paths calculates one shortest path (the path itself, and not just its length) from or to the given vertex.    


ig_ShortPath <-
  shortest_paths(
  igEL,
  from=1,
  to = V(igEL),
  mode = c("all"),
  weights = NULL,
  output = c("epath"), #c("vpath", "epath", "both")
  predecessors = FALSE,
  inbound.edges = FALSE)

  
ig_AllShort <- 
    all_shortest_paths(
      igEL,
      from = 1, # Vertex ID: AkuAku
      to = V(igEL),
      mode = c("all"),
      weights = NULL)$res

##**From=(vertex id)*	
    ##Numeric constant, the vertex from or to the shortest paths 

##**mode=c("out", "all", "in")*

##**output= *	
    ## defines how to report the shortest paths. 
  #**“vpath”* the vertices along the paths are reported, this form was used prior to igraph version 0.6. 
  #**“epath”* edges along the paths are reported. 
  #*“both”* both forms are returned, in a named list with components “vpath” and “epath”.
    
 class(ig_histPath)
  class(ig_ShortPath)
  class(ig_AllShort)
```

Distance between two or more Nodes

```{r iGraph: Distances: Network & Nodes, echo=TRUE}

library(igraph)
# distances calculates the length of all the shortest paths from or to the vertices in the network. 

 mean_distance(igEL, directed = F, unconnected = TRUE)

view(
  distance_table(igEL, directed = F)
)

view(
  igraph::distances(igEL)
)

### distances between specific nodes

    distances(igEL,"AKU AKU" ,  "SINGAPORE SLING",weights=NA)
    distances(igEL,"AKU AKU" ,  "HONDO HATTIE'S JUNGLE PUNCH!",weights=NA)
    distances(igEL,"AKU AKU" ,"KAHIKO PUNCH" ,weights=NA)
    distances(igEL,"AKU AKU" , "JET PILOT"   ,weights=NA)
    distances(igEL,"AKU AKU" , "TRIUMVIRATE PUNCH"   ,weights=NA)
    distances(igEL,"AKU AKU" ,"EUREKA PUNCH" ,weights=NA)
    distances(igEL,"AKU AKU" , "YULETIDAL WAVE" ,weights=NA)
    distances(igEL,"AKU AKU" ,"RUMBUSTION PUNCH"   ,weights=NA)
    distances(igEL,"AKU AKU" ,"PUKA PUNCH",weights=NA)

```

```{r iGraph:Nodes: GRAPH:  Length between Nodes, echo=TRUE}
library(igraph)

class(aku_Puka)

View(
  list(
    aku_Sing,
    aku_Hondo,
    aku_Kahiko,
    aku_JetPilot,
    aku_Trium,
    aku_Eureka,
    aku_YuleTide,
    aku_Rumbustion,
    aku_Puka)
  )


```

Find *all* of the shortest paths between two
specific nodes in this network.

```{r iGraph:Nodes & Network: Path: Shortest , echo=TRUE}
  
# shortest_paths calculates one shortest path (the path itself, and not just its length) from or to the given vertex.
view(
  igraph::shortest.paths(igEL)
  )

#     isolating the distances between specific node
## Note: manually tell igraph to ignore edge weights.


aku_Sing <- all_shortest_paths(igEL,
                     "AKU AKU" ,
                     "SINGAPORE SLING",
                     weights=NA)$res


aku_Hondo <- all_shortest_paths(igEL,
                   "AKU AKU",
                   "HONDO HATTIE'S JUNGLE PUNCH!",
                   weights=NA)$res


aku_Kahiko <- all_shortest_paths(igEL,
                   "AKU AKU",
                   "KAHIKO PUNCH",
                   weights=NA)

aku_JetPilot <- all_shortest_paths(igEL,
                     "AKU AKU", 
                     "JET PILOT",
                     weights=NA)$res
  
aku_Trium <- all_shortest_paths(igEL,
                   "AKU AKU",
                   "TRIUMVIRATE PUNCH",
                   weights=NA)$res
  
aku_Eureka <- all_shortest_paths(igEL,"AKU AKU",
                     "EUREKA PUNCH",
                     weights=NA)$res
  
aku_YuleTide <- all_shortest_paths(igEL,"AKU AKU", 
                     "YULETIDAL WAVE" ,
                     weights=NA)$res
  
aku_Rumbustion <-   all_shortest_paths(igEL,
                     "AKU AKU" ,
                     "RUMBUSTION PUNCH",
                     weights=NA)$res
  
aku_Puka <-   all_shortest_paths(igEL,
                     "AKU AKU" ,
                     "PUKA PUNCH",
                     weights=NA)$res

View(list(
  aku_Sing,
  aku_Hondo,
  aku_Kahiko,
  aku_JetPilot,
  aku_Trium,
  aku_Eureka,
  aku_YuleTide,
  aku_Rumbustion,
  aku_Puka)
)

```

```{r iGraph:Nodes: GRAPH: Shortest between Nodes, echo=TRUE}
library(igraph)

class(aku_Puka)

View(
  list(
    aku_Sing,
    aku_Hondo,
    aku_Kahiko,
    aku_JetPilot,
    aku_Trium,
    aku_Eureka,
    aku_YuleTide,
    aku_Rumbustion,
    aku_Puka)
  )


```

## Component Structure and Membership

### Igraph: Component Structure, Isolates,

```{r iGraph: network density, echo=TRUE}

    #get network density **with** loops
 igraph::graph.density(igEL)
 edge_density(igEL)
          ##**NOTE** provides an incorrect density calculation 
          ## as the default assumes that loops are not included but does not remove them
```

```{r iGraph: Component Structure & Isolates, echo=TRUE}

## Component Structure: 

# Number of Components in a Graph
  count_components(igEL)

# Connected components ?
 igraph::is_connected(igEL)

# Calculate the maximal (weakly or strongly) connected components of a graph

 component_distribution(igEL, 
                       cumulative =F, # relative frequency) is calculated
                       mul.size = F) # multiplied by cluster sizes
                       #**mode= c("strong"/"weak"))*

# a list with: membership by node, size of each component, and the total number of components.

 
 igraph::components(igEL)$no # mode = c("weak", "strong"))
      ##**NOTE:** $no prevents a list of components from being printed
summary(
  igraph::components(igEL,
                     mode = c("weak"))
)

summary(
  igraph::components(igEL,
                     mode = c("strong"))
)
 # Size of each component


 igraph::components(igEL)$csize 



 # Membership of each component 
summary(  
igraph::components(igEL)$membership
)



 
 
```

components are all the same size, so no
interesting plots

### Statnet: Isolates & Component Structure

```{r Statnet: Isolates, echo=TRUE}
library(statnet)
library(sna)
              ## Isolates:
 
 #List the isolates
 isolates(snEL)
 
 # Returns a list of the isolates in the graph or graph set
 isolates(snEL, diag=FALSE)
 
 # Is Ego an Isolate?
 is.isolate(snEL,
            1,# vertex index number (or a vector of vertices)
            g=1, 
            diag=FALSE) #diagonals (i.e., loops) contain meaningful data
 
 # Adds n isolates to the graph (or graphs)
 ##**add.isolates(snEL, n_umber, return.as.edgelist = FALSE)*
 
 #subset vertex.names attribute to get names of isolates
  ##**as.vector(SOURCE.stat%v%'vertex.names')[c(isolates(SOURCE.stat))]*
  
```

```{r Statnet: Component Structure: Component Size Distribution of a Graph, echo=TRUE}
library(statnet)
library(sna)

# Number of Compnents
sna::components(snEL)


# returns a list of vectors: the number of components of graph according to size, length, and membership
summary(
component.dist(snEL)
)

summary(
component.dist(snEL,
               connected=c("unilateral"))
)

summary(
component.dist(
 snEL,
  connected=c("unilateral"))$csize
)

summary(
component.dist(
 snEL,
  connected=c("unilateral"))$cdist 
)



# identifies the component(s) of maximum order within graph
summary(
component.largest(snEL)
)

summary(
component.largest(
 snEL, 
  connected=c("weak"),
  result = c("membership"), # "membership", "graph")
  return.as.edgelist = T)
)

#  computes the component structure of the input network, and returns a vector 

summary(
component.size.byvertex(snEL)
)

summary(
component.size.byvertex(
 snEL, 
  connected = c("unilateral")) # "strong", "weak", "unilateral", "recursive"
)

```

```{r STATNET: Component Size Distribution}
library(statnet)
library(sna)

cd_snEL<- component.dist(
  snEL, 
  connected= c("strong")) # c("strong","weak","unilateral","recursive"))
  summary(cd_snEL)    
  View(cd_snEL)
  
  gplot.layout.circle(cd_snEL)
  
  
cl_snEL <- component.largest(
  snEL, 
  connected = c("strong"), #=c("strong","weak","unilateral" "recursive")
  result = c("graph"), #c("membership", "graph") 
  return.as.edgelist = FALSE)
    
  view(summary(cl_snEL))
  View(cl_snEL)

gplot(cl_snEL)

```

# Week 3:

##### Details: Component Size Distribution

Components are maximal sets of mutually connected
vertices; depending on the definition of
"connected" one employs, one can arrive at several
types of components. Those supported here are as
follows (in increasing order of restrictiveness):

weak: v_1 is connected to v_2 iff there exists a
semi-path from v_1 to v_2 (i.e., a path in the
weakly symmetrized graph)

unilateral: v_1 is connected to v_2 iff there
exists a directed path from v_1 to v_2 or a
directed path from v_2 to v_1

strong: v_1 is connected to v_2 iff there exists a
directed path from v_1 to v_2 and a directed path
from v_2 to v_1

recursive: v_1 is connected to v_2 iff there
exists a vertex sequence v_a,...,v_z such that
v_1,v_a,...,v_z,v_2 and v_2,v_z,...,v_a,v_1 are
directed paths


## Network Density

The density of a network is defined as the
proportion of ties present out of all possible
ties in a network.

**Note:** the network density command ignores edge
values at present. If loops are present or there
are multiple edges between two nodes, then the
results may not make sense.

```{r Statnet: Network Density, echo=TRUE}
library(statnet)
library(sna)

  # computes network density
   network.density(snEL)
  
    network.density(
     snEL, 
     na.omit = T, # Exclude missing edges
     discount.bipartite = FALSE)
  
 # computes the density of  graphs and adjusts for the type of graph 
  gden(snEL)
 
  gden(
    snEL, 
       g=NULL, 
       diag=FALSE, # Set to TRUE if graph contains loops
       mode="graph", # digraph or graph
       ignore.eval=FALSE)
  

  network::is.bipartite(snEL)
  network::has.loops(snEL)
 
```

**Igraph** provides an incorrect density
calculation as the default assumes that loops are
not included but does not remove them.

```{r iGraph: network density / edge density, echo=TRUE}

library(igraph)

    #get network density **with** loops
 igraph::graph.density(
   igEL,
   loops = F)
 
 edge_density(igEL)
          ##**NOTE** provides an incorrect density calculation 
          ## as the default assumes that loops are not included but does not remove them
 
```


## Network & Vertex Degree

### **use the network degree command to:**

-   compute network summary statistics (such as
    average network degree);
-   graph the network degree distribution; or
-   identify particular nodes (such as the five
    nodes with the most contacts). ##\# **Vertex
    degree** is a description of an individual
    node; each vertex in a network may have a
    different node degree.

###*Node Degree:* node degree is one measure of
node centrality or popularity; Node degree cis a
count of the relationships that a node is involved
in or the count of the edges that are incident to
a vertex

### Statnet: Network & Vertex Degree

#### Network Degree
```{r Statnet: Network Degree, echo=TRUE}
library(statnet)
library(sna)
     
 # statnet: Calculate average network degree
summary(  
  sna::degree(snEL))
  
summary(
  sna::degree(snEL, 
             g=1, 
             nodes=NULL, 
             gmode="digraph", #directed;
             diag=FALSE, # contains loops
             tmaxdev=FALSE, 
             cmode="indegree", 
             rescale=FALSE, 
             ignore.eval=FALSE)) # ignores loops or self-nominations 
summary(
  snEL_vd <- sna::degree(snEL, 
             g=1, 
             nodes= NULL, 
             gmode="graph", #undirected
             diag=TRUE, #includes diagonals 
             tmaxdev=F, 
             cmode="freeman", 
             rescale=F, #  scores rescaled to sum to 1.
             ignore.eval=FALSE))

plot(snEL_vd)
#**cmode=* degree centrality being computed. 
#*"indegree"
#*"outdegree"
#**DEFAULT*"freeman" refer to the indegree, outdegree, 
#*total (Freeman) degree measures, respectively. 
```

```{r Statnet: PLOT: Network Degree, echo=TRUE}
library(statnet)
library(sna)
     
 # statnet: Calculate average network degree

summary( snEL_netDeg <-
  sna::degree(snEL))
  
summary( snEL_vdDig  <-
 sna::degree(snEL, 
             g=1, 
             nodes=NULL, 
             gmode="digraph", #directed;
             diag=FALSE, # contains loops
             tmaxdev=FALSE, 
             cmode="indegree", 
             rescale=FALSE, 
             ignore.eval=FALSE)) # ignores loops or self-nominations 
summary(
  snEL_vdG <- sna::degree(snEL, 
             g=1, 
             nodes= NULL, 
             gmode="graph", #undirected
             diag=TRUE, #includes diagonals 
             tmaxdev=F, 
             cmode="freeman", 
             rescale=F, #  scores rescaled to sum to 1.
             ignore.eval=FALSE))

plot(snEL_netDeg)
plot(snEL_vdDig)
plot(snEL_vdG)

#**cmode=* degree centrality being computed. 
#*"indegree"
#*"outdegree"
#**DEFAULT*"freeman" refer to the indegree, outdegree, 
#*total (Freeman) degree measures, respectively. 
```

```{r Statnet: Vertex Degree (Directed Network), echo=TRUE}
library(statnet)
library(sna)

     ## create a dataset of vertex names and degree:
#####
snEL_nDeg <- data.frame(
  name=snEL%v%"vertex.names",
  degree=sna::degree(snEL))

snEL_nDegDig <-data.frame(
    name=snEL%v%"vertex.names",
    degree=sna::degree(snEL),
    indegree=sna::degree(snEL,
                         cmode="indegree"),
    outdegree=sna::degree(snEL,
                          cmode="outdegree"))

snEL_nInDegDig <-data.frame(
    name=snEL%v%"vertex.names",
    indegree=sna::degree(snEL,
                         cmode="indegree"))

snEL_nOutDegDig <-data.frame(
    name=snEL%v%"vertex.names",
    outdegree=sna::degree(snEL,
                          cmode="outdegree"))

```

#### Network Degree Summary Statistics

```{r Statnet: Network Degree: Summary Stats, echo=TRUE}
library(statnet)
library(sna)   
  
 # Basic R: get summary statistics for node attributes
 # provides range, mean, median and standard deviation of a vector.

  summary(snEL_nDeg)
  summary(snEL_nDegDig)
```

```{r Statnet: PLOT: Node Degree, echo=TRUE}
library(statnet)
library(sna)   
  

 # get summary statistics for node degree for the binary network degree
 
snEL_degVtx <- data.frame(
   name=snEL%v%"vertex.names",
   totdegree=sna::degree(snEL),
   indegree=sna::degree(snEL, cmode="indegree"),
   outdegree=sna::degree(snEL, cmode="outdegree"))
gplot(snEL_degDF)

snEL_degVtx <- data.frame(
   name=snEL%v%"vertex.names",
   totdegree=sna::degree(snEL))

   gplot(snEL_degDF)
  summary(snEL_degVNme)
   
snEL_degVNme <- data.frame(
   name=snEL%v%"Aku Aku",
    outdegree=sna::degree(snEL, cmode="outdegree"))
   gplot(snEL_degVNme)
    summary(snEL_degVNme)

snEL_degVNme <- data.frame(
   name=snEL%v%"(1-INCH-SQUARE) CHUNKS PINEAPPLE",
   indegree=sna::degree(snEL, cmode="indegree"))
   
gplot(snEL_degVNme)
summary(snEL_degVNme)

snEL_degVNme <- data.frame(
   name=snEL%v%"MINT LEAVES",
   outdegree=sna::degree(snEL, cmode="outdegree"))
   
gplot(snEL_degVNme)
summary(snEL_degVNme)


snEL_degVNme <- data.frame(
   name=snEL%v%"DEMERARA SYRUP",
   outdegree=sna::degree(snEL, cmode="outdegree"))
   
gplot(snEL_degVNme)
summary(snEL_degVNme)

odeg_peachLqr <- data.frame(
   name=snEL%v%"PEACH LIQUEUR (SUCH AS MATHILDE, COMBIER, OR GIFFARD)",
   outdegree=sna::degree(snEL, cmode="outdegree"))
gplot(odeg_peachLqr)
summary(odeg_peachLqr) 


odeg_blaRum <- data.frame(
   name=snEL%v%" BLENDED LIGHTLY AGED RUM",
   outdegree=sna::degree(snEL, cmode="outdegree"))
gplot(out_blaRum)
summary(out_blaRum)

odeg_val3 <- data.frame(
  
   outdegree=sna::degree(snEL, cmode="outdegree"))


```

#### Network PLOT: Degree Distribution

hist() is a basic R command that draws a histogram
of vector of data

```{r Statnet: HIST: Network Degree Distribution}

library(statnet)
library(sna)   

#create a histogram 
hist(
  snEL_nDegDig$degree, 
  main="Smuggler's Bay: Drink Names & Ingredients: Degree Distribution", 
  xlab="Nominations Received")

hist(
  snEL_nDegDig$indegree, 
  main="Smuggler's Bay: Drink Names & Ingredients: In-degree Distribution"
  , xlab="Nominations Received")

hist(
  snEL_nDegDig$outdegree, 
     main="Smuggler's Bay: Drink Names & Ingredients: Out-degree Distribution ", 
     xlab="Nominations made")


```

```{r Statnet: HIST: Node Degree Distribution, echo=TRUE}
library(statnet)
library(sna)   
  
 # get summary statistics for node degree for the binary network degree
 
### AKU AKU   
snEL_degVNme <- data.frame(
   name=snEL%v%"Aku Aku",
    outdegree=sna::degree(snEL, cmode="outdegree"),
    indegree=sna::degree(snEL, cmode="indegree"))
   
hist(
  snEL_degVNme$outdegree, 
  main="Drink Name:  Aku Aku: Out Degree Distribution", 
  xlab="Nominations Received")

hist(
  snEL_degVNme$indegree, 
  main="Drink Name:  Aku Aku: Out Degree Distribution", 
  xlab="Nominations Received")

## "(1-INCH-SQUARE) CHUNKS PINEAPPLE"
snEL_degVNme <- data.frame(
   name=snEL%v%"(1-INCH-SQUARE) CHUNKS PINEAPPLE",
   indegree=sna::degree(snEL, cmode="indegree"),
   outdegree=sna::degree(snEL, cmode="outdegree"))
   
hist(
  snEL_degVNme$outdegree, 
  main="Drink Ingredient: (1-INCH-SQUARE) CHUNKS PINEAPPLE Out Degree Distribution", 
  xlab="Nominations Received")

hist(
  snEL_degVNme$indegree, 
  main="Drink Ingredient: Drink Ingredient: (1-INCH-SQUARE) CHUNKS PINEAPPLE in Degree Distribution", 
  xlab="Nominations Received")

## Mint Leaves 
snEL_degVNme <- data.frame(
   name=snEL%v%"MINT LEAVES",
   indegree=sna::degree(snEL, cmode="indegree"),
   outdegree=sna::degree(snEL, cmode="outdegree"))
   
hist(
  snEL_degVNme$outdegree, 
  main="Out Degree: Drink Ingredient: ", 
  xlab="Nominations Received")

hist(
  snEL_degVNme$indegree, 
  main="In Degree: Drink Ingredient: " , 
  xlab="Nominations Received")


## "DEMERARA SYRUP"
snEL_degVNme <- data.frame(
   name=snEL%v%"DEMERARA SYRUP",
   indegree=sna::degree(snEL, cmode="indegree"),
   outdegree=sna::degree(snEL, cmode="outdegree"))

hist(
  snEL_degVNme$outdegree, 
  main="Out Degree: Drink Ingredient: DEMERARA SYRUP", 
  xlab="Nominations Received")

hist(
  snEL_degVNme$indegree, 
  main="In Degree: Drink Ingredient:  DEMERARA SYRUP", 
  xlab="Nominations Received")
   
## Peach Liqueur
odeg_peachLqr <- data.frame(
   name=snEL%v%"PEACH LIQUEUR (SUCH AS MATHILDE, COMBIER, OR GIFFARD)",
   indegree=sna::degree(snEL, cmode="indegree"),
   outdegree=sna::degree(snEL, cmode="outdegree"))

hist(
  snEL_degVNme$outdegree, 
  main="Out Degree: Drink Ingredient: PEACH LIQUEUR", 
  xlab="Nominations Received")

hist(
  snEL_degVNme$indegree, 
  main="In Degree: Drink Ingredient: PEACH LIQUEUR" , 
  xlab="Nominations Received")

   
## " BLENDED LIGHTLY AGED RUM"
odeg_blaRum <- data.frame(
   name=snEL%v%"BLENDED LIGHTLY AGED RUM",
   indegree=sna::degree(snEL, cmode="indegree"),
   outdegree=sna::degree(snEL, cmode="outdegree"))


hist(
  snEL_degVNme$outdegree, 
  main="Out Degree: Drink Ingredient: BLENDED LIGHTLY AGED RUM ", 
  xlab="Nominations Received")

hist(
  snEL_degVNme$indegree, 
  main="In Degree: Drink Ingredient: BLENDED LIGHTLY AGED RUM " , 
  xlab="Nominations Received")
   
```

### iGraph: Vertex Degree

```{r iGraph: Vertex Degree, echo=TRUE}
# igraph: Calculate average network degree
 # provides node name along with node degree
 
 # includes loops
  plot(igraph::degree(igEL))


```


## Network degree Centrilization
### Degree Centrality

We can break large social networks down into their
constituent parts. These constituent parts are
referred to as "motifs". The most basic motif
consists of two nodes and is called a dyad. Edges
in a network signify the presence or absence of
dyadic relations. It follows that a dyad in an
undirected network can have two unique
configurations: connected or disconnected; and
three unique configurations in a directed network
(mutual, assymetric, and null

### Statnet: Degree Centraility: In/Out

```{r Statnet: Network Degree centralization, eval=FALSE, include=FALSE}
library(statnet)
library(sna)

#get network centralization score:
 
# centralization(snEL, degree, cmode="indegree")

```

```{r Statmet: Netweork Centrality:  low & high degree nodes}

#sort to find 5 highest and lowest degree nodes in trade100

network::list.edge.attributes(snEL)

snEL_nodeHeadTail <-data.frame(
  name=snEL%v%"vertex.names",
  indegree=sna::degree(snEL, cmode="indegree"),
  outdegree=sna::degree(snEL, cmode="outdegree"))

snEL_nodeHeadTail%>%
  arrange(desc(indegree))%>%
  slice(1:10)

snEL_nodeHeadTail%>%
  arrange(indegree)%>%
  slice(1:10)

snEL_nodeHeadTail%>%
  arrange(desc(outdegree))%>%
  slice(1:10)

snEL_nodeHeadTail%>%
  arrange(outdegree)%>%
  slice(1:10)

view(snEL_nodeHeadTail)


```

### Igraph: Degree Centrality 

```{r iGraph: DEGREE CENTRALITY}
library(igraph)
library(tidyverse)

#get network centralization score: 

summary(
  centr_degree(igEL)$res)

  centr_degree(igEL)$centralization

summary(
  centr_degree(igEL)$centralization)

  centr_degree(igEL)$theoretical_max


#get network centralization score: in 
  
  centr_degree(
    igEL, 
    loops = FALSE, 
    mode="in")$centralization

summary(
  centr_degree(
    igEL, 
    loops = FALSE, 
    mode="in")$centralization)  
  
  centr_degree(
    igEL, 
    mode ="in")$theoretical_max

#get network centralization score: out
  
  centr_degree(
    igEL, 
    loops = FALSE, 
    mode="out")$centralization

summary(
  centr_degree(
    igEL, 
    loops = FALSE, 
    mode="out")$centralization)

  centr_degree(
    igEL,
    mode ="out")$theoretical_max
  
## get network centralization score: ALL
  

summary(
  centr_degree(igEL,
  mode = c("all"),
  loops = TRUE,
  normalized = TRUE)$res)


centr_degree(igEL,
  mode = c("all"),
  loops = TRUE,
  normalized = TRUE)$centralization



centr_degree(igEL,
  mode = c("all"),
  loops = TRUE,
  normalized = TRUE)$theoretical_max

```

```{r iGraph: PLOT: DEGREE CENTRALITY}
library(igraph)
library(tidyverse)

# network centralization score: 
plot(
  centr_degree(igEL)$res)

hist(
  centr_degree(igEL)$res
)


#get network centralization score: in 

hist(
  centr_degree(igEL,mode = c("in"))$res)

  centr_degree(
    igEL, 
    loops = FALSE, 
    mode="in")$centralization
  
  centr_degree(igEL,
               mode ="in")$theoretical_max
#get network centralization score: out
  
  centr_degree(
    igEL, 
    loops = FALSE, 
    mode="out")$centralization
  
  centr_degree(
    igEL,
    mode ="out")$theoretical_max
  
  ##
summary(
  centr_degree(
    igEL, 
    loops = FALSE, 
    mode="out")$centralization)


summary(
  centr_degree(igEL,
  mode = c("all"),
  loops = TRUE,
  normalized = TRUE)$res)

plot(
  centr_degree(igEL,mode = c("all"))$res)


summary(
centr_degree(igEL,
  mode = c("all"),
  loops = TRUE,
  normalized = TRUE)$centralization
)

summary(
centr_degree(igEL,
  mode = c("all"),
  loops = TRUE,
  normalized = TRUE)$theoretical_max
)
  
```


```{r iGraph: PLOT: Degree Centrality}
# Degree centrality is calculated using the degree function in R. It returns how many edges each node has.
view(degree(igEL))

ingT_deg <- igEL
V(ingT_deg)$degree <- degree(ingT_deg) # assignment

plot(ingT_deg, 
     vertex.label.cex = .6, 
     vertex.label.color = "black", 
     vertex.size = V(igEL)$degree, 
     vertex.label.cex = .2) # sized by degree

```

# WEEK4
```{r iGraph: Directed: Betweenness Centrality}

view(betweenness(igEL, directed = FALSE))

# view(betweenness(igEL, directed = TRUE))
              # Yeilds 0

ingTypEL_Between <- igEL
# We can again assign the output of betweenness() to a variable in the network and size the nodes according to it.

V(ingTypEL_Between)$betweenness <- 
  betweenness(ingTypEL_Between, 
              directed = F)

# plot(ingTypEL_Between, 
#     vertex.label.cex = .6, 
#     vertex.label.color = "black", 
#     vertex.size = V(ingTypEL_Between)$betweenness) # sized by betweenness


```

```{r iGraph: UnDirected:  Closeness Centrality}

view(closeness(igEL))
  
  # We assign it to a node variable and plot the network, adjusting node size by closeness.
ingTyp_Cent <- igEL #**UNDIRECTED **

V(ingTyp_Cent)$closeness <- closeness(ingTyp_Cent)

View(ingTyp_Cent)

# plot(ingTyp_Cent,
#     vertex.label.cex = .6, 
#     vertex.label.color = "black", 
#     vertex.size = V(ingTyp_Cent)$closeness/max(V(ingTyp_Cent)$closeness) * 20)


```

Degree centrality only takes into account the
number of edges for each node, but it leaves out
information about ego's alters

```{r iGraph: Directed: Eigenvector Centrality}

view(evcent(igEL)$vector)
# view(evcent(igEL)$vector)
ingTyp_Vector <- igEL
V(ingTyp_Vector)$eigenvector <- evcent(ingTyp_Vector)$vector

# plot(ingTyp_Vector,
#     vertex.label.cex = .6, 
#     vertex.label.color = "black", 
#     vertex.size = V(ingTyp_Vector)$eigenvector/max(V(ingTyp_Vector)$eigenvector) * 20)
```

```{r iGraph: Directed: Bonacich Centrality}

ingTyp_Cent <- igEL

V(ingTyp_Cent)$bonacich <- 
  power_centrality(ingTyp_Cent, exponent = -2, rescale = T)

V(ingTyp_Cent)$bonacich <- 
  ifelse(V(ingTyp_Cent)$bonacich < 0, 0, V(ingTyp_Cent)$bonacich)
```

```{r iGraph: Directed: Page Rank}

ingTyp_Cent <- igEL

V(ingTyp_Cent)$page_rank <- page_rank(ingTyp_Cent, directed = TRUE)$vector

```

plot(ingTyp_Cent, vertex.label.cex = .6,
vertex.label.color = "black", vertex.size =
V(ingTyp_Cent)$page_rank/max(V(ingTyp_Cent)$page_rank)
\* 20)
