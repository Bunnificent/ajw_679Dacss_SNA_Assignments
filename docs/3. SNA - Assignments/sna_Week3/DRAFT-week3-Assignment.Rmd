---
title: "DRAFT: Week 3: Degree and Centrality"
description: " "
author:
  - name: "Audra Jamai White" 
    url: 
    affiliation: "Umass Amherst - DACSS 679: Social Network Analysis"
    affiliation_url: 
date: "`r Sys.Date()`"
output: distill::distill_article
---

```{r setup, Libraries, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

# Document Creation
library(knitr)
library(markdown)
library(yaml)
library(distill)
library(blogdown)

# Basic Analysis
library(ggplot2)
library(tidyverse)
library(clipr)
library(dbplyr)
library(data.table)
library(stringr)
library(stringi)
library(tibble)
library(tidyr)

# SNA - Social Network Analysis

library(tergm)
library(ergm)
library(network)
library(networkDynamic)
library(networkDynamicData)

library(statnet)
library(igraph)
library(igraphdata)
library(tsna)
library(sna)

```
  
## Briefly describe the dataset:
1.   identify initial network format; 
2.   describe and identify the nodes 
     including: 
        *  how many nodes are in the dataset; 
3.   what constitutes a tie or edge
     including:
        *  how many ties, 
        *   whether ties are directed/undirected,
        *   whether ties are weighted/binary, 
        *   and how to interpret the value of the tie if any.
        *   Whether or not there are edge attributes 
            that might be used to:
            *   subset data, or 
            *   stack multiple networks. 

# Week 2: Scripts

## Smuggler's Index: Network Attributes 
```{r Network Size}

  print(snEL)
  print(igEL)
  
  summary(snEL)
  summary(igEL)

```

###   IGRAPH:   Network Description
*igraph*
- Network Size
  - Number Vertex: 274
    - attr: name (v/c)
  - Number Edges: 672
    - attr: ingTyp (e/c)
- Bipartite: FALSE
- Directed: FALSE
- Weighted: FALSE

Names
- Vertex Names: view
- Edge Attribute Names: [1] "ingTyp"
```{r igraph: Network & Attribute Descripions, echo=TRUE} 

## Network Size
#     Count Vertices
    vcount(igEL)
#     Count Edges
    ecount(igEL)

## Network Attributes
    
# Is this a Bipartite or single mode network?
    is_bipartite(igEL)

#  Are edges directed or undirected?
    is_directed(igEL)

#Are edges weighted or unweighted?
    is_weighted(igEL)        
    
# vertex attribute names
  igraph::vertex_attr_names(igEL)

#   edge attributes  names
  igraph::edge_attr_names(igEL)

#   summarize numeric network attribute
#**summary(E(igEL)$weight)*

```

```{r igraph: Vetex & Edge Names, echo=TRUE}
library(igraph)

#     access vertex attribute 
  head(
    V(igEL)$name,20)

#     access edge attribute
  head(E(igEL)$ingTyp, 20)

```

 
###   STATNET:   Network Description 

```{r statnet: Network Summary & Attribute info, echo=TRUE}
print(snEL)

print(summary(snEL))

#      list the names of vertex attributes
  network::list.vertex.attributes(snEL)
#  Generate a list the names of edge attributes
  network::list.edge.attributes(snEL)
 
#   summarize numeric network attribute
  summary(snEL%v%"name")
  summary(snEL%v%"ingNam")
  summary(snEL%v%"dnkNam")
  summary(snEL%e%"ingTyp")
  
  
#     access vertex & edge attribute names
 head(snEL %v% "vertex.names")
#     access edge attribute
  head(snEL%e%"ingTyp")
  
```


## Dyad Census

Classifies all dyads in the network as:
- Mutual - Reciprocal (mutual) 
- Asymmetric -  (non-mutual), 
- Null - Absent


```{r iGraph: Dyad Census, echo=TRUE}
library(igraph)

dyad.census(igEL)
print("Undirected graph, $asym is 0")

```

```{r iGraph: Dyad: Graph Density / Edge Density, echo=TRUE}
library(igraph)

  graph.density(igEL)

summary(
  graph.density(igEL)
)
 
    ## Density captures, at the macro-level, the proportion of dyads that are present over the possible total number of dyads in the network
  
  edge_density(igEL)
  
summary(
   edge_density(igEL)
)

      # Generating a random graph for comparison
# erdos.renyi.game
      ## In an erdos.renyi.graph, each edge has the same probability of being created. We determine the probability and it returns a random graph with a density that equals (in expectation) this probability.

igEL_Nod <- vcount(igEL)

igEL_Den <- graph.density(igEL)

 igEL_randoGraph <- erdos.renyi.game(
    n = igEL_Nod, 
    p.or.m = igEL_Den, 
    directed = T) 
      # where n is the number of nodes, 
      # p.or.m is the probability of drawing an edge, 
      #directed is whether the network is directed or not
 class(igEL_randoGraph)
 summary(igEL_randoGraph)
 
 
 print_all(igEL_randoGraph)

```

plot(igEL_randoGraph,
      vertex.size = 5, 
      vertex.label = NA, 
      edge.curved = .1, 
      vertex.color = "tomato", 
      edge.arrow.size = .1, 
      edge.width = .5, 
     edge.color = "grey60")

```{r statnet: Dyad Count / Dyad Census , echo=TRUE}
library(statnet)
library(sna)

 network.dyadcount(snEL)
 sna::dyad.census(snEL)
 
     print("statnet thinks it's a directed network, so there are no mutual ties because it's an undirected network and the 'names' and 'ingredients' in a recipie do not have a reciprocal relationship. If anything the 'flow of info' moves from 'Drink Name' to 'Drink Ingredient' to 'Ingredient type'. The Drink name determines the recipie ingredients, but we're unable to identify a drink by calling on individual ingredients in a recipie")  
  
```

gplot(sna::dyad.census(snEL))

```{r statnet: GRecip / Mutuality, echo=TRUE}
library(statnet)
library(sna)
  
#  the number of complete dyads (i.e., i<->j)
mutuality(snEL)


  grecip(snEL) 
  
    #proportion of symmetric dyads
  grecip(snEL, 
         measure = "dyadic") 
  
      # returns the ratio of mutuals to non-null dyads.
  grecip(snEL, 
         measure = "dyadic.nonnull") 
  
      # the proportion of edges which are reciprocated
  grecip(snEL, 
         measure = "edgewise") 
  
      # returns the log of the ratio of the edgewise reciprocity to the density
  grecip(snEL, 
         measure = "edgewise.lrr") 
      
  # The correlation measure may be interpreted as the net tendency for edges of similar relative value (with respect to the mean edge value) to occur within the same dyads. 

    grecip(snEL, 
         measure = "correlation") 
```



## Triad Census

Classifies all triads in the network. 


```{r iGraph: Triad Census, echo=TRUE}
library(igraph)
#Classify all Triad in the network

sum(
  triad_census(igEL)
)

list(
  triad_census(igEL)
)



```
plot(
  triad_census(igEL)
)

```{r statnet: Triad Census / Triad Classify, echo=TRUE}
library(sna)

#     total number of all four triad types returned by triad census
sum(
  sna::triad.census(
    snEL,
    mode="graph"))


#     Classify all Triad in the network: Undirected Network
 sna::triad.census(
     snEL,
     mode="graph")

  
#Davis and Leinhardt classification of the triad classification scheme 
   # describes each triad by a string of four elements: 
   # the number of mutual (complete) dyads within the triad; 
   # the number of asymmetric dyads within the triad; 
   # the number of null (empty) dyads within the triad; 
   #and a configuration code for the triads which are not uniquely distinguished by the first three distinctions.
   
sna::triad.classify(
     snEL,
     tri=c(1,2,3),
     mode==c("graph")
   )

```



## Transitivity or Global Clustering

Perportion of connected triads to complete triads

```{r iGraph: Transitivity Network, echo=TRUE}
library(igraph)

# Calculate the maximal (weakly or strongly) connected components of a graph
igraph::cluster.distribution()

#     network transitivity:
 transitivity(igEL)

 summary(  
  transitivity(
   igEL,
   type = c("undirected"),
   vids = NULL, #  all vertices are considered.
   weights = NULL,
   isolates = c("NaN", "zero"))
)

summary( 
 transitivity(igEL,
             type = c("globalundirected"),
             vids = NULL, #  all vertices are considered.
             weights = NULL,
             isolates = c("NaN", "zero"))
)

summary(
  transitivity(igEL,
             type = c("localundirected"),
             vids = NULL, #  all vertices are considered.
             weights = NULL,
              isolates = c("NaN", "zero"))
)
#   c("undirected", "global", "globalundirected", "localundirected", "local","average", "localaverage","localaverageundirected", "barrat", "weighted")

```
plot(
  transitivity(igEL,
             type = c("localundirected"),
             vids = NULL, #  all vertices are considered.
             weights = NULL,
              isolates = c("NaN", "zero"))
)
```{r statnet: Transitivity:, echo=FALSE}
library(statnet)
library(sna)

#   Networks transitivity:
print("Networks transitivity:")  
print("Note: where missing values prevent the assessment of whether a triple is transitive, that triple is omitted.")

print("use.adjacency=FALSE -> 0: completely intransitive ")        
  gtrans(snEL,
         mode="digraph", #"digraph" for triads 
         use.adjacency=FALSE)

print("use.adjacency=TRUE -> 1: completely transitive")
  gtrans(snEL, 
         mode="graph", # No triads
         use.adjacency=TRUE)

# Unaffected by mode=digrag/graph, diag(nal)=F/T
      
#   measure = 
  ## c("weak", "strong", "weakcensus", "strongcensus", "rank", "correlation"), 

print("Weak Ties: fraction of potentially intransitive triads returned")
  ## Weak Ties
  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("weak"),
    use.adjacency=FALSE)
    
  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("weak"),
     use.adjacency=TRUE)
   
print("weak census: total number of transitive triads is computed")  
  ## "weakcensus"
  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("weakcensus"),
    use.adjacency=TRUE)

  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("weakcensus"),
    use.adjacency=FALSE)

  
print("strong ties")  
  ## Strong Ties
  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("strong"),
    use.adjacency=TRUE)

  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("strong"),
    use.adjacency=FALSE)
  
print("strongcensus: total number of all (in/transitive) triad sets considered")
  ## "strongcensus"
gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("strongcensus"),
    use.adjacency=FALSE)

  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("strongcensus"),
    use.adjacency=TRUE)
  
print("rank")  
  ##  "rank"
gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c( "rank"),
    use.adjacency=FALSE)
  
  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c( "rank"),
    use.adjacency=TRUE)
  
  
  ## "correlation"
print("correlation: the matrix correlation of the valued adjacency matrix A with its second power (i.e., A^2), omitting diagonal entries where inapplicable.")
  
  gtrans(
    snEL,
    g=NULL,
    mode="graph", 
    measure = c("correlation"),
    use.adjacency=TRUE)

```



## Ego Network Transivity or Local Clustering

`Local transitivity` (local clustering coefficient), is a technical description of the density of an ego network.

```{r iGraph: Local / Ego Network Transitivity, echo=TRUE}
#     get global clustering cofficient
  transitivity(igEL,
               type="global")

#     get average local clustering coefficient
  transitivity(igEL,
               type="average")


#     check ego network transitivity
transitivity(igEL,
             type="undirected",
             vids=V(igEL)[c(
               "AKU AKU", 
               "SINGAPORE SLING",
               "HONDO HATTIE'S JUNGLE PUNCH!")])

```

```{r statnet: Local / Ego Network Transitivity}
library(statnet)
library(sna)
print("Ego Network Transitivity")

print("use.adjacency=TRUE -> 1: completely transitive")
gtrans(
    snEL,
    g=snEL%v%"AKU AKU",
    use.adjacency=T)

gtrans(
    snEL,
    g=snEL%v%"LIME JUICE",
    use.adjacency=T)

print("use.adjacency=FALSE -> 0: completely intransitive ")        
gtrans(
    snEL,
    g=snEL%v%"AKU AKU",
    use.adjacency=FALSE)

gtrans(
    snEL,
    g=snEL%v%"LIME JUICE",
    use.adjacency=FALSE)

#   measure = 
  ## c("weak", "strong", "weakcensus", "strongcensus", "rank", "correlation"), 


print("strong ties")  
  ## Strong Ties
  gtrans(
    snEL,
      g=snEL%v%"AKU AKU",
    mode="digraph", 
    measure = c("strong"),
    use.adjacency=FALSE)

  gtrans(
    snEL,
    g=snEL[c(
      "AKU AKU,KAHIKO PUNCH", "TRIUMVIRATE PUNCH", "EUREKA PUNCH",
      "YULETIDAL WAVE","RUMBUSTION PUNCH", "PUKA PUNCH")],
    mode="graph", 
    measure = c("strong"),
    use.adjacency=FALSE)
  
  gtrans(
    snEL,
    g=snEL%v%"LIME JUICE",
    mode="graph", 
    measure = c("strong"),
    use.adjacency=F)
  
 gtrans(
    snEL,
     g=snEL[c(
       "LIME JUICE","2:1 SIMPLE SYRUP","ALLSPICE BERRIES",
       "APPLE BRANDY"  ,"ABSINTHE BLANC","AQUAVIT","AMARO AVERNA")],
    mode="graph", 
    measure = c("strong"),
    use.adjacency=F)
 
  
print("strongcensus: total number of all (in/transitive) triad sets considered")
  
print("strongcensus")
    ## "strongcensus"
  gtrans(
    snEL,
      g=snEL%v%"AKU AKU",
    mode="graph", 
    measure = c("strongcensus"))

gtrans(
    snEL,
    g=snEL[c(
      "AKU AKU,KAHIKO PUNCH", "TRIUMVIRATE PUNCH", "EUREKA PUNCH",
      "YULETIDAL WAVE","RUMBUSTION PUNCH", "PUKA PUNCH")],
    mode="graph", 
    measure = c("strongcensus"))

gtrans(
    snEL,
   g=snEL%v%"LIME JUICE",
    mode="graph", 
    measure = c("strongcensus"))

  gtrans(
    snEL,
     g=snEL[c("LIME JUICE","2:1 SIMPLE SYRUP","ALLSPICE BERRIES","APPLE BRANDY"  ,"ABSINTHE BLANC","AQUAVIT","AMARO AVERNA")],
    mode="graph", 
    measure = c("strongcensus"))

```


##  Path Length and Geodesic Distance

- Nodes: 
  - (v/c) Drink Names
  - (v/c) Drink Ingredients
- Links: 
  - (e/c)  Ingredient Type

###  Statnet:   Path Length and Geodesic Distance
 
```{r STATNET: Plot: Geodesic: Numbers and Lengths }
library(statnet)
library(sna)

#uses a BFS to find the number and lengths of geodesics between all nodes 


 gd_snEL <- geodist(
    snEL, 
    inf.replace=.5, #geodesics do not exist, substitute value
    count.paths=TRUE, 
    predecessors=T, # return predecessor list
    ignore.eval=F, # ignore edge values
    na.omit=F) # remove NA values

summary(gd_snEL)
view(
  list(gd_snEL))
  
  #Examine the number of geodesics
snEL_gdCounts <- gd_snEL$counts


#Examine the geodesic distances
snEL_gdist  <- gd_snEL$gdist
  
```
gplot(gd_snEL)
gplot(snEL_gdist)



```{r STATNET:Path: Reachability}
library(statnet)
library(sna)

summary(
  reachability(
    snEL,
    geodist.precomp=NULL,
    return.as.edgelist=FALSE,
    na.omit=FALSE)
)
```


```{r STATNET:Path: Geodesic number & lengths}
library(statnet)
library(sna)

summary(geodist(snEL, 
        inf.replace=Inf, 
        count.paths=TRUE, # include geodesics 
        predecessors=FALSE,# include predecessor list
        ignore.eval=FALSE, # ignore edge values
        na.omit=FALSE) # remove NA-values edges
        )

#Examine the number of geodesics
gd_snEL$counts

#Examine the geodesic distances
gd_snEL$gdist

  summary(gd_snEL)
  gplot(gd_snEL)
  
```

```{r STATNET:Path: k Path Census}
library(statnet)
library(sna)

summary(kpath.census(snEL, 
             maxlen = 5, 
             mode = "graph",
             tabulate.by.vertex = TRUE, 
             path.comembership = c("none"), # c("none", "sum","bylength"), 
             dyadic.tabulation = c("none") # c("none", "sum", "bylength"))
))
              ##**"sum"* returns a vertex by vertex matrix of source/destination path counts
             ##**"bylength"* disaggregates these counts by path length. 
             ##**"none"* disables this computation.


```
- Aggregate counts of paths/cycles by length (i.e., k).

- Counts of paths/cycles to which each vertex belongs (when tabulate.byvertex==TRUE).

- Counts of path/cycle co-memberships, potentially disaggregated by length (when the appropriate co-membership argument is set to bylength).

- For path.census, counts of the total number of paths from each vertex to each other vertex, possibly disaggregated by length (if dyadic.tabulation=="bylength").


###  IGRAPH:   Path Length and Geodesic Distance

```{r iGraph:Nodes: Path: Length, echo=TRUE}
library(igraph)



```


  The shortest path to describe the overall network structure 
```{r iGraph:Network: Path: Shortest, echo=TRUE}

#     find average shortest path for network
    average.path.length(igEL,directed=F)   

  
```   
  

```{r iGraph:Nodes: Path: Length, echo=TRUE}

library(igraph)
# Head
list(
  head(V(igEL)$name,10),
  tail(V(igEL)$name,10)
  )

#     Calculate distance between two nodes using unweighted edges
 
    distances(igEL,"AKU AKU" ,  "SINGAPORE SLING",weights=NA)
    distances(igEL,"AKU AKU" ,  "HONDO HATTIE'S JUNGLE PUNCH!",weights=NA)
    distances(igEL,"AKU AKU" ,"KAHIKO PUNCH" ,weights=NA)
    distances(igEL,"AKU AKU" , "PASSION FRUIT HONEY"   ,weights=NA)
    distances(igEL,"AKU AKU" , "TRIUMVIRATE PUNCH"   ,weights=NA)
    distances(igEL,"AKU AKU" ,"EUREKA PUNCH" ,weights=NA)
    distances(igEL,"AKU AKU" , "YULETIDAL WAVE" ,weights=NA)
    distances(igEL,"AKU AKU" ,"RUMBUSTION PUNCH"   ,weights=NA)
    distances(igEL,"AKU AKU" ,"PUKA PUNCH",weights=NA)

```

Find *all* of the shortest paths between two specific nodes in this network.

```{r iGraph:Nodes: Path: Shortest, echo=TRUE}
    
#     isolating the distances between specific node

## Note: manually tell igraph to ignore edge weights.


aku_Sing <- all_shortest_paths(igEL,
                     "AKU AKU" ,
                     "SINGAPORE SLING",
                     weights=NA)$res


aku_Hondo <- all_shortest_paths(igEL,
                   "AKU AKU",
                   "HONDO HATTIE'S JUNGLE PUNCH!",
                   weights=NA)$res


aku_Kahiko <- all_shortest_paths(igEL,
                   "AKU AKU",
                   "KAHIKO PUNCH",
                   weights=NA)

aku_PFhoney <- all_shortest_paths(igEL,
                     "AKU AKU", 
                     "PASSION FRUIT HONEY",
                     weights=NA)$res
  
aku_Trium <- all_shortest_paths(igEL,
                   "AKU AKU",
                   "TRIUMVIRATE PUNCH",
                   weights=NA)$res
  
aku_Eureka <- all_shortest_paths(igEL,"AKU AKU",
                     "EUREKA PUNCH",
                     weights=NA)$res
  
aku_YuleTide <- all_shortest_paths(igEL,"AKU AKU", 
                     "YULETIDAL WAVE" ,
                     weights=NA)$res
  
aku_Rumbustion <-   all_shortest_paths(igEL,
                     "AKU AKU" ,
                     "RUMBUSTION PUNCH",
                     weights=NA)$res
  
aku_Puka <-   all_shortest_paths(igEL,
                     "AKU AKU" ,
                     "PUKA PUNCH",
                     weights=NA)$res
```   

### Statnet: Component STructure, Isolates, Density
```{r Statnet: Isolates, echo=TRUE}

              ## Isolates:
 
 #List the isolates
 isolates(snEL)
 
 # Returns a list of the isolates in the graph or graph set
 isolates(snEL, diag=FALSE)
 
 # Is Ego an Isolate?
 is.isolate(snEL, ego_exp, g=1, diag=FALSE)
 
 # Adds n isolates to the graph (or graphs)
 add.isolates(snEL, n_umber, return.as.edgelist = FALSE)
  
```

```{r Statnet: Network Density, echo=TRUE}

            # get network density: with possible loops
   network.density(snEL)
          ##**WARNING: Network is multiplex - no general way to define density.** 

 # get network density **with** loops: statnet
 gden(snEL, diag=F)
 
 
```


### Igraph: Component STructure, Isolates,
```{r iGraph: Undirected: Component Structure, echo=TRUE}
                ## Component Structure: 
 
    # Number of components
 igraph::components(igEL)$no 
      ##**NOTE:** $no prevents a list of components from being printed
  
# Size of each component
 igraph::components(igEL)$csize 

 
```

```{r iGraph: Undirected: network density, echo=TRUE}

    #get network density **with** loops
 network.density(igEL)
 class(igEL)
          ##**NOTE** provides an incorrect density calculation 
          ## as the default assumes that loops are not included but does not remove them
 
```
 **Igraph** provides an incorrect density calculation as the default assumes  that loops are not included but does not remove them. 
 
 Therefore, the default calculation includes the loops in the numerator but not the denominator of the density calculation.





## Component Structure and Membership


# Week 3: 

```{r STATNET: Component Size Distribution}
library(statnet)
library(sna)

cd_snEL<- component.dist(
  snEL, 
  connected= c("strong")) # c("strong","weak","unilateral","recursive"))
  summary(cd_snEL)    
  View(cd_snEL)
  
  gplot.layout.circle(cd_snEL)
  
  
cl_snEL <- component.largest(
  snEL, 
  connected = c("strong"), #=c("strong","weak","unilateral" "recursive")
  result = c("graph"), #c("membership", "graph") 
  return.as.edgelist = FALSE)
    
  view(summary(cl_snEL))
  View(cl_snEL)

gplot(cl_snEL)

```

##### Details: Component Size Distribution 
Components are maximal sets of mutually connected vertices; depending on the definition of “connected” one employs, one can arrive at several types of components. Those supported here are as follows (in increasing order of restrictiveness):

weak: v_1 is connected to v_2 iff there exists a semi-path from v_1 to v_2 (i.e., a path in the weakly symmetrized graph)

unilateral: v_1 is connected to v_2 iff there exists a directed path from v_1 to v_2 or a directed path from v_2 to v_1

strong: v_1 is connected to v_2 iff there exists a directed path from v_1 to v_2 and a directed path from v_2 to v_1

recursive: v_1 is connected to v_2 iff there exists a vertex sequence v_a,...,v_z such that v_1,v_a,...,v_z,v_2 and v_2,v_z,...,v_a,v_1 are directed paths

## Network Density
 
 The density of a network is defined as the proportion of ties present out of all possible ties in a network. 
 

 **Note:**
 
 the network density command ignores edge values at present. 
 
 If loops are present or there are multiple edges between two nodes, then the results may not make sense.
 
 

```{r Statnet: Network Density, echo=TRUE}

            # get network density: with possible loops
   network.density(snEL)
          ##**WARNING: Network is multiplex - no general way to define density.** 

 # get network density **with** loops: statnet

  gden(snEL, diag=F)

```

 **Igraph** provides an incorrect density calculation as the default assumes  that loops are not included but does not remove them. 
 
```{r iGraph: edge density, echo=TRUE}
library(igraph)
    #get network density **with** loops
edge_density(igEL, loops = FALSE)
 
 
 class(igEL)
          ##**NOTE** provides an incorrect density calculation 
          ## as the default assumes that loops are not included but does not remove them
 
```

## Vertex Degree
 **Vertex degree** is a description of an individual node; each vertex in a network may have a different node degree.
 
 
 *Node Degree:*
   node degree is one measure of node centrality or popularity; 
 Node degree cis a count of the relationships that a node is involved in or the count of the edges that are incident to a vertex
 
 **use the network degree command to:**
   *  compute network summary statistics (such as average network degree);
 *  graph the network degree distribution; or
 *  identify particular nodes (such as the five nodes with the most contacts).
 


```{r Statnet: Vertex Degree, echo=TRUE}
library(statnet)
library(sna)
      # statnet: Calculate average network degree
summary(sna::degree(snEL, 
             g=1, 
             nodes=NULL, 
             gmode="digraph", #directed;
             diag=FALSE, #excludes diagonals 
             tmaxdev=FALSE, 
             cmode="indegree", 
             rescale=FALSE, 
             ignore.eval=FALSE))
          # ignores loops or self-nominations 
summary(
  snEL_vd <- sna::degree(snEL, 
             g=1, 
             nodes= NULL, 
             gmode="graph", #undirected
             diag=TRUE, #includes diagonals 
             tmaxdev=F, 
             cmode="freeman", 
             rescale=F, #  scores rescaled to sum to 1.
             ignore.eval=FALSE))
plot(snEL_vd)
#**cmode=* degree centrality being computed. 
#*"indegree"
#*"outdegree"
#**DEFAULT*"freeman" refer to the indegree, outdegree, 
#*total (Freeman) degree measures, respectively. 
```

```{r iGraph: Undirected: Vertex Degree, echo=TRUE}
# igraph: Calculate average network degree
 # provides node name along with node degree
 
 # includes loops
  plot(igraph::degree(igEL))


```



## Network Degree Summary Statistics

```{r Statnet: , echo=TRUE}
library(statnet)
library(sna)   
   # Basic R: get summary statistics for node attributes
 
summary(snEL_Deg <- 
           sna::degree(snEL))
    plot(snEL_Deg)

      # provides range, mean, median and standard deviation of a vector.

 # get summary statistics for node degree for the binary network degree
 
snEL_degVtx <- data.frame(
   name=snEL%v%"vertex.names",
   totdegree=sna::degree(snEL),
   indegree=sna::degree(snEL, cmode="indegree"),
   outdegree=sna::degree(snEL, cmode="outdegree"))
gplot(snEL_degDF)

snEL_degVtx <- data.frame(
   name=snEL%v%"vertex.names",
   totdegree=sna::degree(snEL))

   gplot(snEL_degDF)
  summary(snEL_degVNme)
   
snEL_degVNme <- data.frame(
   name=snEL%v%"Aku Aku",
    outdegree=sna::degree(snEL, cmode="outdegree"))
   gplot(snEL_degVNme)
    summary(snEL_degVNme)

snEL_degVNme <- data.frame(
   name=snEL%v%"(1-INCH-SQUARE) CHUNKS PINEAPPLE",
   indegree=sna::degree(snEL, cmode="indegree"))
   
gplot(snEL_degVNme)
summary(snEL_degVNme)

snEL_degVNme <- data.frame(
   name=snEL%v%"MINT LEAVES",
   outdegree=sna::degree(snEL, cmode="outdegree"))
   
gplot(snEL_degVNme)
summary(snEL_degVNme)


snEL_degVNme <- data.frame(
   name=snEL%v%"DEMERARA SYRUP",
   outdegree=sna::degree(snEL, cmode="outdegree"))
   
gplot(snEL_degVNme)
summary(snEL_degVNme)

odeg_peachLqr <- data.frame(
   name=snEL%v%"PEACH LIQUEUR (SUCH AS MATHILDE, COMBIER, OR GIFFARD)",
   outdegree=sna::degree(snEL, cmode="outdegree"))
gplot(odeg_peachLqr)
summary(odeg_peachLqr) 


odeg_blaRum <- data.frame(
   name=snEL%v%" BLENDED LIGHTLY AGED RUM",
   outdegree=sna::degree(snEL, cmode="outdegree"))
gplot(out_blaRum)
summary(out_blaRum)

odeg_val3 <- data.frame(
  
   outdegree=sna::degree(snEL, cmode="outdegree"))


```
 
 6/274 vertices, named, from 1bfe0b4:
[1] (1-INCH-SQUARE) CHUNKS PINEAPPLE                     
[2] MINT LEAVES                                          
[3] LIME JUICE                                           
[4] DEMERARA SYRUP                                       
[5] PEACH LIQUEUR (SUCH AS MATHILDE, COMBIER, OR GIFFARD)
[6] BLENDED LIGHTLY AGED RUM  

## Centrilization 

```{r iGraph: Undirected: DEGREE CENTRALITY: dnkIng}
library(igraph)
library(tidyverse)

plot(centr_degree(igEL)$res)

summary(
  centr_degree(igEL,
  mode = c("all"),
  loops = TRUE,
  normalized = TRUE)$res)

plot(
  centr_degree(igEL,mode = c("all"))$res)


summary(
centr_degree(igEL,
  mode = c("all"),
  loops = TRUE,
  normalized = TRUE)$centralization
)

summary(
centr_degree(igEL,
  mode = c("all"),
  loops = TRUE,
  normalized = TRUE)$theoretical_max
)
  
```


## Degree Centrality
We can break large social networks down into their constituent parts. These constituent parts are referred to as “motifs”. The most basic motif consists of two nodes and is called a dyad. Edges in a network signify the presence or absence of dyadic relations. It follows that a dyad in an undirected network can have two unique configurations: connected or disconnected; and three unique configurations in a directed network (mutual, assymetric, and null

```{r iGraph: Directed: GRAPH: Dyad Census, echo=TRUE}

graph.density(igEL)
    ## Density captures, at the macro-level, the proportion of dyads that are present over the possible total number of dyads in the network

      # Generating a random graph for comparison
# ?erdos.renyi.game
      ## In an erdos.renyi.graph, each edge has the same probability of being created. We determine the probability and it returns a random graph with a density that equals (in expectation) this probability.

igELNod <- vcount(igEL)

igELDen <- graph.density(igEL)

smugEL_DigRandoG <- 
  erdos.renyi.game(
    n = igELNod, 
    p.or.m = igELDen, 
    directed = T) 
      # where n is the number of nodes, 
      # p.or.m is the probability of drawing an edge, 
      #directed is whether the network is directed or not

#**plot(smugEL_DigRandoG, ...** in .R notebook  
     # vertex.size = 5, 
     # vertex.label = 1, 
     # edge.curved = .1, 
     # vertex.color = "tomato", 
     # edge.arrow.size = .1, 
     # edge.width = .5, 
     # edge.color = "grey60")

```


```{r iGraph: Directed: Degree Centrality}
# Degree centrality is calculated using the degree function in R. It returns how many edges each node has.
view(degree(igEL))

ingT_deg <- igEL
V(ingT_deg)$degree <- degree(ingT_deg) # assignment

# plot(ingT_deg, 
#     vertex.label.cex = .6, 
#     vertex.label.color = "black", 
#     vertex.size = V(igEL)$degree, 
#     vertex.label.cex = .2) # sized by degree

```


```{r iGraph: Directed: Betweenness Centrality}

view(betweenness(igEL, directed = FALSE))

# view(betweenness(igEL, directed = TRUE))
              # Yeilds 0

ingTypEL_Between <- igEL
# We can again assign the output of betweenness() to a variable in the network and size the nodes according to it.

V(ingTypEL_Between)$betweenness <- 
  betweenness(ingTypEL_Between, 
              directed = F)

# plot(ingTypEL_Between, 
#     vertex.label.cex = .6, 
#     vertex.label.color = "black", 
#     vertex.size = V(ingTypEL_Between)$betweenness) # sized by betweenness


```


```{r iGraph: UnDirected:  Closeness Centrality}

view(closeness(igEL))
  
  # We assign it to a node variable and plot the network, adjusting node size by closeness.
ingTyp_Cent <- igEL #**UNDIRECTED **

V(ingTyp_Cent)$closeness <- closeness(ingTyp_Cent)

View(ingTyp_Cent)

# plot(ingTyp_Cent,
#     vertex.label.cex = .6, 
#     vertex.label.color = "black", 
#     vertex.size = V(ingTyp_Cent)$closeness/max(V(ingTyp_Cent)$closeness) * 20)


```


Degree centrality only takes into account the number of edges for each node, but it leaves out information about ego’s alters
```{r iGraph: Directed: Eigenvector Centrality}

view(evcent(igEL)$vector)
# view(evcent(igEL)$vector)
ingTyp_Vector <- igEL
V(ingTyp_Vector)$eigenvector <- evcent(ingTyp_Vector)$vector

# plot(ingTyp_Vector,
#     vertex.label.cex = .6, 
#     vertex.label.color = "black", 
#     vertex.size = V(ingTyp_Vector)$eigenvector/max(V(ingTyp_Vector)$eigenvector) * 20)
```


```{r iGraph: Directed: Bonacich Centrality}

ingTyp_Cent <- igEL

V(ingTyp_Cent)$bonacich <- 
  power_centrality(ingTyp_Cent, exponent = -2, rescale = T)

V(ingTyp_Cent)$bonacich <- 
  ifelse(V(ingTyp_Cent)$bonacich < 0, 0, V(ingTyp_Cent)$bonacich)
```

```{r iGraph: Directed: Page Rank}

ingTyp_Cent <- igEL

V(ingTyp_Cent)$page_rank <- page_rank(ingTyp_Cent, directed = TRUE)$vector

```

 plot(ingTyp_Cent,
     vertex.label.cex = .6, 
     vertex.label.color = "black", 
     vertex.size = V(ingTyp_Cent)$page_rank/max(V(ingTyp_Cent)$page_rank) * 20)
